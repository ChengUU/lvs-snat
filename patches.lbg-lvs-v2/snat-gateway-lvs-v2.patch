diff --git a/kernel/net/netfilter/ipvs/ip_vs_core.c b/kernel/net/netfilter/ipvs/ip_vs_core.c
index f6c373b..e4685f7 100644
--- a/kernel/net/netfilter/ipvs/ip_vs_core.c
+++ b/kernel/net/netfilter/ipvs/ip_vs_core.c
@@ -346,6 +346,15 @@ struct ip_vs_conn *ip_vs_schedule(struct ip_vs_service *svc,
 	/*
 	 *    Create a connection entry.
 	 */
+  
+  if (svc->fwmark == 1)
+    cp = ip_vs_conn_new(svc->af, iph.protocol,
+            &iph.saddr, pptr[0],
+            &iph.daddr, pptr[1],
+            &iph.daddr, pptr[1],
+            ip_vs_onepacket_enabled(svc, &iph),
+            dest, skb, is_synproxy_on);
+  else
 	cp = ip_vs_conn_new(svc->af, iph.protocol,
 			    &iph.saddr, pptr[0],
 			    &iph.daddr, pptr[1],
@@ -779,6 +788,47 @@ handle_response(int af, struct sk_buff *skb, struct ip_vs_protocol *pp,
 	return ret;
 }
 
+static unsigned int
+ip_vs_snat_out(int af, struct sk_buff *skb, struct ip_vs_protocol *pp,
+		  int *v, struct ip_vs_conn *cp)
+{
+  if (cp && cp->dest && cp->dest->svc
+      && cp->dest->svc->fwmark != 1)
+    return 1;
+
+  EnterFunction(11);
+  if (!cp) {
+    skb->mark = 1;
+    if (!pp->conn_schedule(af, skb, pp, v, &cp))
+      return 0;
+
+    if (unlikely(!cp)) {
+      /* sorry, all this trouble for a no-hit :) */
+      IP_VS_DBG_PKT(12, pp, skb, 0,
+              "packet continues traversal as normal");
+      *v = NF_ACCEPT;
+      return 0;
+    }
+  }
+
+  IP_VS_DBG_PKT(11, pp, skb, 0, "Forward packet");
+  ip_vs_in_stats(cp, skb);
+
+  ip_vs_set_state(cp, IP_VS_DIR_INPUT, skb, pp);
+
+  if (cp->packet_xmit)
+		*v = cp->packet_xmit(skb, cp, pp);
+	/* do not touch skb anymore */
+	else {
+		IP_VS_DBG_RL("warning: packet_xmit is null");
+		*v = NF_ACCEPT;
+	}
+  
+  cp->old_state = cp->state;
+  ip_vs_conn_put(cp);
+  return 0;
+}
+
 /*
  *	It is hooked at the NF_INET_FORWARD chain, used only for VS/NAT.
  *	Check if outgoing packet belongs to the established ip_vs_conn.
@@ -793,6 +843,7 @@ ip_vs_out(unsigned int hooknum, struct sk_buff *skb,
 	struct ip_vs_conn *cp;
 	int af;
 	int res_dir;
+        int verdict;
 
 	EnterFunction(11);
 
@@ -851,6 +902,10 @@ ip_vs_out(unsigned int hooknum, struct sk_buff *skb,
 	 */
 	cp = pp->conn_out_get(af, skb, pp, &iph, iph.len, 0, &res_dir);
 
+  if (0 == ip_vs_snat_out(af, skb, pp, &verdict, cp)) {
+    return verdict;
+  }
+
 	if (unlikely(!cp)) {
 		if (sysctl_ip_vs_nat_icmp_send &&
 		    (pp->protocol == IPPROTO_TCP ||
